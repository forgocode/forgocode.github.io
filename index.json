[{"categories":[],"content":"本文主要记录了在网页中使用vim的快捷键（根据需求来），使用插件surfingkeys实现 ","date":"2023-05-03","objectID":"/posts/vim/vim%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88/:0:0","tags":[],"title":"Vim网页浏览","uri":"/posts/vim/vim%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88/"},{"categories":[],"content":"标签页 E 跳转到左侧标签页 R 跳转到右侧标签页 x 关闭当前标签页 X 恢复刚关闭的标签页 T 选择打开的标签页 on 新建新标签页 ","date":"2023-05-03","objectID":"/posts/vim/vim%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88/:1:0","tags":[],"title":"Vim网页浏览","uri":"/posts/vim/vim%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88/"},{"categories":[],"content":"搜索栏 og 打开谷歌搜索栏 ow 打开bing搜索 ob 打开百度搜素 ","date":"2023-05-03","objectID":"/posts/vim/vim%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88/:2:0","tags":[],"title":"Vim网页浏览","uri":"/posts/vim/vim%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88/"},{"categories":[],"content":"收藏夹 ab 收藏当前页面 b 打开收藏夹 ","date":"2023-05-03","objectID":"/posts/vim/vim%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88/:3:0","tags":[],"title":"Vim网页浏览","uri":"/posts/vim/vim%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88/"},{"categories":[],"content":"网页浏览 S 后退 D 前进 r 刷新当前页 ","date":"2023-05-03","objectID":"/posts/vim/vim%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88/:4:0","tags":[],"title":"Vim网页浏览","uri":"/posts/vim/vim%E7%BD%91%E9%A1%B5%E6%B5%8F%E8%A7%88/"},{"categories":["Linux"],"content":"本文主要记录了使用vim的一些快捷键，随用随记。 w 移动到下一个单词的首部 e 移动到当前单词的尾部 b 移动到当前单词的首部 % 跳转到当前当前括号的另一半 :jumps 查看跳转记录 g; 跳转到下一次修改的地方，g,跳转到下上一次修改的地方 viw + U 将单词转化为大写 ","date":"2023-05-03","objectID":"/posts/vim/vim%E7%BC%96%E8%BE%91%E5%99%A8/:0:0","tags":["Vim","Linux"],"title":"Vim编辑器","uri":"/posts/vim/vim%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"本文主要介绍了cgroup的概念，以及机制 ","date":"2023-05-03","objectID":"/posts/linux/cgroup%E4%BB%8B%E7%BB%8D/:0:0","tags":["Linux"],"title":"Cgroup介绍","uri":"/posts/linux/cgroup%E4%BB%8B%E7%BB%8D/"},{"categories":["Linux"],"content":"cgroup介绍 cgroup的全称是是control groups，控制组。是内核提供的对物理资源隔离的机制，通过这种机制，就可以对单个进程或者一组进程进行资源隔离/限制。比如：可以通过cgroup限制指定进程可以使用的cpu和内存数量，超过时可以选择暂停或者杀掉，这个也是docker和k8s实现的基础。 ","date":"2023-05-03","objectID":"/posts/linux/cgroup%E4%BB%8B%E7%BB%8D/:1:0","tags":["Linux"],"title":"Cgroup介绍","uri":"/posts/linux/cgroup%E4%BB%8B%E7%BB%8D/"},{"categories":["Linux"],"content":"基本概念 任务。在cgroup中，任务就是进程 控制组。控制组指明了该控制组下面所有进程的资源配额。进程可以加入到某个控制组，也可以迁移到另外一个控制组 层级。 控制组可以多层嵌套，子控制组继承父控制组的属性 子系统 资源监视器。比如memory子系统可以控制进程内存的使用，子系统需要加入到某个层级，然后该层级的所有控制组都受到这个子系统的控制 子进程自动加入父进程的控制组。但是可以迁移 两个层级在有且只有一个子系统的时候，可以共享 一个层级可以有多个子系统 一个任务可以是多个控制组的成员，但这些控制组只能在不同的层级 ","date":"2023-05-03","objectID":"/posts/linux/cgroup%E4%BB%8B%E7%BB%8D/:1:1","tags":["Linux"],"title":"Cgroup介绍","uri":"/posts/linux/cgroup%E4%BB%8B%E7%BB%8D/"},{"categories":["Linux"],"content":"子系统 cpu: 限制进程的 cpu 使用率。 cpuacct 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。 cpuset: 为cgroups中的进程分配单独的cpu节点或者内存节点。 memory: 限制进程的memory使用量。 blkio: 限制进程的块设备io。 devices: 控制进程能够访问某些设备。 net_cls: 标记cgroups中进程的网络数据包，然后可以使用tc模块（traffic control）对数据包进行控制。 net_prio: 限制进程网络流量的优先级。 huge_tlb: 限制HugeTLB的使用。 freezer:挂起或者恢复cgroups中的进程。 ns: 控制cgroups中的进程使用不同的namespace。 ","date":"2023-05-03","objectID":"/posts/linux/cgroup%E4%BB%8B%E7%BB%8D/:1:2","tags":["Linux"],"title":"Cgroup介绍","uri":"/posts/linux/cgroup%E4%BB%8B%E7%BB%8D/"},{"categories":["Linux"],"content":"使用 内核将cgroup的功能和配置入口通过虚拟文件系统暴露给用户态， 目录在/sys/fs/cgroup下面 cpu子系统 cpu.shares: cgroup对时间的分配。比如cgroup A设置的是1，cgroup B设置的是2，那么B中的任务获取cpu的时间，是A中任务的2倍。 cpu.cfs_period_us: 完全公平调度器的调整时间配额的周期。 cpu.cfs_quota_us: 完全公平调度器的周期当中可以占用的时间。 cpu.stat 统计值 nr_periods 进入周期的次数 nr_throttled 运行时间被调整的次数 throttled_time 用于调整的时间 cpyacct子系统(只是cpu资源报告，不做资源限制) uacct.usage: 该cgroup中所有任务总共使用的CPU时间（ns纳秒） cpuacct.stat: 该cgroup中所有任务总共使用的CPU时间，区分user和system时间。 cpuacct.usage_percpu: 该cgroup中所有任务使用各个CPU核数的时间。 cpuset子系统 cpuset.cpus: 可以使用的cpu节点 cpuset.mems: 可以使用的mem节点 cpuset.memory_migrate: 内存节点改变是否要迁移？ cpuset.cpu_exclusive: 此cgroup里的任务是否独享cpu？ cpuset.mem_exclusive： 此cgroup里的任务是否独享mem节点？ cpuset.mem_hardwall: 限制内核内存分配的节点（mems是用户态的分配） cpuset.memory_pressure: 计算换页的压力。 cpuset.memory_spread_page: 将page cache分配到各个节点中，而不是当前内存节点。 cpuset.memory_spread_slab: 将slab对象(inode和dentry)分散到节点中。 cpuset.sched_load_balance: 打开cpu set中的cpu的负载均衡。 cpuset.sched_relax_domain_level: the searching range when migrating tasks cpuset.memory_pressure_enabled: 是否需要计算 memory_pressure? memory memory.usage_in_bytes # 当前内存中的使用量 memory.memsw.usage_in_bytes # 当前内存和交换空间中的使用量 memory.limit_in_bytes # 设置or查看内存使用量 memory.memsw.limit_in_bytes # 设置or查看 内存加交换空间使用量 memory.failcnt # 查看内存使用量被限制的次数 memory.memsw.failcnt # - 查看内存和交换空间使用量被限制的次数 memory.max_usage_in_bytes # 查看内存最大使用量 memory.memsw.max_usage_in_bytes # 查看最大内存和交换空间使用量 memory.soft_limit_in_bytes # 设置or查看内存的soft limit memory.stat # 统计信息 memory.use_hierarchy # 设置or查看层级统计的功能 memory.force_empty # 触发强制page回收 memory.pressure_level # 设置内存压力通知 memory.swappiness # 设置or查看vmscan swappiness 参数 memory.move_charge_at_immigrate # 设置or查看 controls of moving charges? memory.oom_control # 设置or查看内存超限控制信息(OOM killer) memory.numa_stat # 每个numa节点的内存使用数量 memory.kmem.limit_in_bytes # 设置or查看 内核内存限制的硬限 memory.kmem.usage_in_bytes # 读取当前内核内存的分配 memory.kmem.failcnt # 读取当前内核内存分配受限的次数 memory.kmem.max_usage_in_bytes # 读取最大内核内存使用量 memory.kmem.tcp.limit_in_bytes # 设置tcp 缓存内存的hard limit memory.kmem.tcp.usage_in_bytes # 读取tcp 缓存内存的使用量 memory.kmem.tcp.failcnt # tcp 缓存内存分配的受限次数 memory.kmem.tcp.max_usage_in_bytes # tcp 缓存内存的最大使用量 ","date":"2023-05-03","objectID":"/posts/linux/cgroup%E4%BB%8B%E7%BB%8D/:1:3","tags":["Linux"],"title":"Cgroup介绍","uri":"/posts/linux/cgroup%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"本文主要介绍了docker的UnionFS（联合文件系统）的解决方案-overlay2 ","date":"2023-05-03","objectID":"/posts/docker/docker_overlay2/:0:0","tags":["Docker","云原生"],"title":"Docker_overlay2","uri":"/posts/docker/docker_overlay2/"},{"categories":["Docker"],"content":"发展历程 docker在最开始的时候使用的是AUFS和DeviceMapper作为联合文件系统的驱动。在内核3.18中，linux引入了overlay，Docker此时开始使用overlay作为UnionFS的解决方案。但由于第一代的overlay存在很多弊端，比如在运行一段时间之后，docker会报too many links perblem的错误，所以在内核4.0的时候对overlay做了很多必要的改进。此时的overlayFS 被称为overlay2. ","date":"2023-05-03","objectID":"/posts/docker/docker_overlay2/:1:0","tags":["Docker","云原生"],"title":"Docker_overlay2","uri":"/posts/docker/docker_overlay2/"},{"categories":["Docker"],"content":"使用overlay2的条件 ","date":"2023-05-03","objectID":"/posts/docker/docker_overlay2/:2:0","tags":["Docker","云原生"],"title":"Docker_overlay2","uri":"/posts/docker/docker_overlay2/"},{"categories":["Docker"],"content":"Docker版本高于17.06.02 ","date":"2023-05-03","objectID":"/posts/docker/docker_overlay2/:2:1","tags":["Docker","云原生"],"title":"Docker_overlay2","uri":"/posts/docker/docker_overlay2/"},{"categories":["Docker"],"content":"Linux版本 如果是Centos/RHEL，linux内核必须高于3.10.0-54。其他发行版本内核必须高于4.0 ","date":"2023-05-03","objectID":"/posts/docker/docker_overlay2/:2:2","tags":["Docker","云原生"],"title":"Docker_overlay2","uri":"/posts/docker/docker_overlay2/"},{"categories":["Docker"],"content":"overlay2 工作原理 overlay2和AUFS类似，他把所有的目录都称为层（layer），overlay2的目录是容器和进行镜像分层的基础，把这些层统一展现到一层的过程叫做联合挂载（union mount）。overlay2把目录的下一层称为lowerdir，上一层叫做upperdir，联合挂载后的目录叫做merged。 简单来讲，overlay2在每一层只存储改动的文件，记录上下层之间的关系，构造镜像/容器的时候，执行联合挂载，在容器中看到完整的系统文件 overlay2文件系统最多支持128层文件挂载 ","date":"2023-05-03","objectID":"/posts/docker/docker_overlay2/:3:0","tags":["Docker","云原生"],"title":"Docker_overlay2","uri":"/posts/docker/docker_overlay2/"},{"categories":["Docker"],"content":"overlay2如何读取，修改，删除文件 主要用到了写时复制技术（copy-on-write） ","date":"2023-05-03","objectID":"/posts/docker/docker_overlay2/:4:0","tags":["Docker","云原生"],"title":"Docker_overlay2","uri":"/posts/docker/docker_overlay2/"},{"categories":["Docker"],"content":"读取文件 读取文件的时候先从容器层（可读写层）查找，如果没找到，就从镜像层（只读层）复制一份到容器层。 ","date":"2023-05-03","objectID":"/posts/docker/docker_overlay2/:4:1","tags":["Docker","云原生"],"title":"Docker_overlay2","uri":"/posts/docker/docker_overlay2/"},{"categories":["Docker"],"content":"修改文件 直接修改容器层中复制过来的文件 ","date":"2023-05-03","objectID":"/posts/docker/docker_overlay2/:4:2","tags":["Docker","云原生"],"title":"Docker_overlay2","uri":"/posts/docker/docker_overlay2/"},{"categories":["Docker"],"content":"删除文件 删除容器层的文件，然后将只读层对应的文件置为不可访问，并没有真正删除该文件 ","date":"2023-05-03","objectID":"/posts/docker/docker_overlay2/:4:3","tags":["Docker","云原生"],"title":"Docker_overlay2","uri":"/posts/docker/docker_overlay2/"},{"categories":["网络"],"content":"本文主要介绍了iptables的相关知识 ","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:0:0","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["网络"],"content":"iptables iptables+netfilter实现了防火墙的功能，其中netfilter是一个包过滤的内核框架，iptables可以认为是一个命令行工具实现对netfilter功能的使用 ","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:1:0","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["网络"],"content":"基本组成 主要是四表五链，四表是raw，mangle，filter，nat。五链是PREROUTING, FORWARD, POSTROUTING, INPUT, OUTPUT ","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:2:0","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["网络"],"content":"表-table raw mangle filter nat ","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:2:1","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["网络"],"content":"链-chain PERROUTINE POSTROUTING FORWARD INPUT OUTPUT ","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:2:2","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["网络"],"content":"流量走向 进入本机的流量 PREROUTING -\u003e INPUT -\u003e 应用程序 从本机到外面的流量 应用程序 -\u003e OUTPUT -\u003e POSTROUTING 通过本机转发的流量 PREROUTING -\u003e FORWARD -\u003ePOSTROUTING ","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:3:0","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["网络"],"content":"匹配原则 先链后表，匹配顺序如下: ","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:4:0","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["网络"],"content":"相关参数 ","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:5:0","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["网络"],"content":"匹配条件 ","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:5:1","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["网络"],"content":"执行动作 -j ACCEPT DROP REJECT SNAT DNAT MASQUERADE REDIRECT LOG NFQUEUE RETURN ","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:5:2","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["网络"],"content":"相关命令","date":"2023-05-02","objectID":"/posts/%E7%BD%91%E7%BB%9C/iptables/:6:0","tags":["网络","Iptables"],"title":"Iptables","uri":"/posts/%E7%BD%91%E7%BB%9C/iptables/"},{"categories":["Kubernetes"],"content":"本文主要介绍k8s使用的经常使用的网络插件，以及基本原理。 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/:0:0","tags":["Kubernetes","云原生"],"title":"Kubernetes网络插件","uri":"/posts/kubernetes/kubernetes%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/"},{"categories":["Kubernetes"],"content":"flannel ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/:1:0","tags":["Kubernetes","云原生"],"title":"Kubernetes网络插件","uri":"/posts/kubernetes/kubernetes%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/"},{"categories":["Kubernetes"],"content":"三种网络模式 udp（性能很差） vxlan（性能一般，常用） host-gw（性能最好） howt-gw模式的工作原理，就是将每个Flannel子网的下一跳，设置成了该子网对应的宿主机的IP地址，也就是说，宿主机（host）充当了这条容器通信路径的“网关”（Gateway），这正是host-gw的含义 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/:1:1","tags":["Kubernetes","云原生"],"title":"Kubernetes网络插件","uri":"/posts/kubernetes/kubernetes%E7%BD%91%E7%BB%9C%E6%8F%92%E4%BB%B6/"},{"categories":["Kubernetes"],"content":"本文主要对k8s进行一个简单的基本介绍，对其相关的组件和基本概念有一个大概的了解 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:0:0","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"Kubernetes 是什么 Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。简单来说，k8s就是一个管理工具，管理的对象就是容器。其中，在Master 节点上运行着集群管理相关的一组进程。这些进程实现了整个集群的资源管理、Pod调度、弹性伸缩、安全控制、系统监控和纠错等管理功能，并且都是全自动完成的。Node作为集群中的工作节点，运行真正的应用程序，在Node上Kubernetes管理的最小运行单元是Pod。Node上运行着Kubernetes的kubelet、kube-proxy服务进程，这些服务进程负责Pod的创建、启动、监控、重启、销毁，以及实现软件模式的负载均衡器。 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:1:0","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"三个命令行工具 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:2:0","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"kubeadm kubeadm init这个命令初始化集群，如果在这里出现了错误的话在命令后面加上–v=5，后面的数字越大，表示打印出来的信息等级就越高 kubeadm init --pod-network-cidr=192.169.1.0/16 这段命令的意思就是初始化一个集群，所有在这个集群上创建pod的IP都属于192.168.0.0/16这个IP段内，其中master这个节点上的IP范围是192.168.1.0/16。 kubeadm join这个命令是把其他主机添加到master这个集群里。后面要跟的参数就是前面通过kubeadm init生成的令牌 kubeadm reset 还原 kubeadm init 或者 kubeadm join 对主机所做的任何更改 kubeadm token管理kubeadm init生成的令牌，可以查看，也可以重新生成，因为这个令牌是每隔24原来的令牌就会失效一次，如果此时想要重新添加主机到这个集群里面，就必须重新生成令牌kubeadm token create/list `kubeadm token create/list`查看口令token #查看后面的哈希值 -kubeadm token create --print-join-command 这个命令会直接生成一个新的命令 -kubeadm token create 生成新的token -openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin-outform der 2\u003e/dev/null | openssl dgst -sha256 -hex | sed 's/^.* //' 算出新的哈希值，其实都一样 #查看各个节点的状态 kubectl get node 执行kubeadm init之后会得到的三个命令 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 这个就是kubectl的配置文件， ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:2:1","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"kubectl 这个命令就是k8s为我们提供的命令行工具 apply/create 创建资源 kuebctl apply -f pod.yml delete 删除资源 kubectl delete -f pod.yml get/describe 查看资源 kubectl get pod -o wide -n namesapce /-A kubectl describe pod (pod_name)查看资源的详细信息 api-resources 查看所有的api kubectl api-resources exec 进入某个容器 kubectl exec -it pod_name -n namespace -c containers bash/sh ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:2:2","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"kubelet kubelet 是在每个 Node 节点上运行的主要 “节点代理”。他是基于 PodSpec 来工作的。每个 PodSpec 是一个描述 Pod 的 YAML 或 JSON 对象。 kubelet 接收通过各种机制（主要是通过 apiserver）提供的一组 PodSpec，并确保这些 PodSpec 中描述的容器处于运行状态且运行状况良好。 kubelet 不管理不是由 Kubernetes 创建的容器。主要有以下几个功能： pod 管理：kubelet 定期从所监听的数据源获取节点上 pod/container 的期望状态（运行什么容器、运行的副本数量、网络或者存储如何配置等等），并调用对应的容器平台接口达到这个状态。 容器健康检查：kubelet 创建了容器之后还要查看容器是否正常运行，如果容器运行出错，就要根据 pod 设置的重启策略进行处理。 容器监控：kubelet 会监控所在节点的资源使用情况，并定时向 master 报告，资源使用数据都是通过 cAdvisor 获取的。知道整个集群所有节点的资源情况，对于 pod 的调度和正常运行至关重要。 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:2:3","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"基础概念 从大到小，有两个角色，一个是master节点，另一个是worker节点。 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:3:0","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"master 上面有各种组件 apiserver k8s API Server提供了k8s各类资源对象（pod,RC,Service等）的增删改查及watch等HTTP Rest接口，是整个系统的数据总线和数据中心。提供其他模块之间的数据交互和通信的枢纽（其他模块通过API Server查询或修改数据，只有API Server才直接操作etcd） kubelet 与 apiserver交互 每个Node节点上的kubelet定期就会调用API Server的REST接口报告自身状态，API Server接收这些信息后，将节点状态信息更新到etcd中。kubelet也通过API Server的Watch接口监听Pod信息，从而对Node机器上的POD进行管理。 kube-controller-manager与API Server交互 kube-controller-manager中的Node Controller模块通过API Server提供的Watch接口，实时监控Node的信息，并做相应处理。 kube-scheduler与API Server交互 Scheduler通过API Server的Watch接口监听到新建Pod副本的信息后，它会检索所有符合该Pod要求的Node列表，开始执行Pod调度逻辑。调度成功后将Pod绑定到目标节点上。 特别说明: 为了缓解各模块对API Server的访问压力，各功能模块都采用缓存机制来缓存数据，各功能模块定时从API Server获取指定的资源对象信息（LIST/WATCH方法），然后将信息保存到本地缓存，功能模块在某些情况下不直接访问API Server，而是通过访问缓存数据来间接访问API Server。 scheduler 功能概览 调度 是指将 Pod 放置到合适的 Node 上，然后对应 Node 上的 Kubelet 才能够运行这些 pod。调度器通过 kubernetes 的监测（Watch）机制来发现集群中新创建且尚未被调度到 Node 上的 Pod。 调度器会将发现的每一个未调度的 Pod 调度到一个合适的 Node 上来运行。 调度器会依据下文的调度原则来做出调度选择。 对每一个新创建的 Pod 或者是未被调度的 Pod，kube-scheduler 会选择一个最优的 Node 去运行这个 Pod。然而，Pod 内的每一个容器对资源都有不同的需求，而且 Pod 本身也有不同的资源需求。因此，Pod 在被调度到 Node 上之前， 根据这些特定的资源调度需求，需要对集群中的 Node 进行一次过滤。 在一个集群中，满足一个 Pod 调度请求的所有 Node 称之为 可调度节点。 如果没有任何一个 Node 能满足 Pod 的资源请求，那么这个 Pod 将一直停留在 未调度状态直到调度器能够找到合适的 Node。 调度器先在集群中找到一个 Pod 的所有可调度节点，然后根据一系列函数对这些可调度节点打分， 选出其中得分最高的 Node 来运行 Pod。之后，调度器将这个调度决定通知给 kube-apiserver，这个过程叫做 绑定。 在做调度决定时需要考虑的因素包括：单独和整体的资源请求、硬件/软件/策略限制、 亲和以及反亲和要求、数据局域性、负载间的干扰等等。 调度流程 过滤 找到所有可供选择的节点 （可以进行信息设置，以及配置优先级）(预选算法、可供选择) 打分 确定资源发布到得分最高的节点上面（优选算法） controller-manager 在manager内部有一组控制器节点控制器（Node Controller），副本控制器（Replication Controller），端点控制器（Endpoints Controller），服务帐户和令牌控制器（Service Account \u0026 Token Controllers）。从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。每一种控制器会追踪不同类型的资源，每一种资源对象都有一个spec的字段 。这个字段说明了在这个集群中该项资源的预期状态，而控制器就是负责该项资源的当前状态尽可能接近期望状态。 Job 是一种 Kubernetes 资源，它运行一个或者多个 Pod， 来执行一个任务然后停止。在集群中，当 Job 控制器拿到新任务时，它会保证一组 Node 节点上的 kubelet 可以运行正确数量的 Pod 来完成工作。 Job 控制器不会自己运行任何的 Pod 或者容器。Job 控制器是通知 API 服务器来创建或者移除 Pod。 控制面中的其它组件 根据新的消息作出反应（调度（scheduler）并运行新 Pod（kubelet））并且最终完成工作。 kube proxy 在每个节点上运行 代理 UDP、TCP 和 SCTP 不支持 HTTP 提供负载均衡能力 只用来访问 Service apiserver proxy 是一个建立在 apiserver 内部的“堡垒” 将集群外部的用户与群集 IP 相连接，这些IP是无法通过其他方式访问的 运行在 apiserver 进程内 客户端到代理使用 HTTPS 协议 (如果配置 apiserver 使用 HTTP 协议，则使用 HTTP 协议) 通过可用信息进行选择，代理到目的地可能使用 HTTP 或 HTTPS 协议 可以用来访问 Node、 Pod 或 Service 当用来访问 Service 时，会进行负载均衡 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:3:1","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"其他概念 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:4:0","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"pod pod创建流程 1.用户通过kubectl命名发起请求 2.apiserver通过对应的kubeconfig进行认证，认证通过后将yaml中的pod信息存到etcd。 3.Controller-Manager通过apiserver的watch接口发现了pod信息的更新，执行该资源所依赖的拓扑结构整合，整合后将对应的信息写到etcd，此时pod已经可以被调度了。 4.Scheduler同样通过apiserver的watch接口更新到pod可以被调度，通过算法给pod分配节点，并将pod和对应节点绑定的信息写到etcd，然后将pod交给kubelet。 5.kubelet收到pod后，调用CNI接口给pod创建pod网络，调用CRI接口去启动容器，调用CSI进行存储卷的挂载。 6.网络，容器，存储创建完成后pod创建完成，等业务进程启动后，pod运行成功。 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:4:1","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"service 分布式集群架构的核心：Service(服务) 一个Service对象有如下关键特征： 一个唯一指定的名字 一个虚拟IP和端口号 能够提供某种远程服务能力 被映射到了提供这种服务能力的一组容器应用 服务进程基于socket进程对外提供服务，虽然一个Service 通常由多个相关的服务进程来提供服务，每个服务进程都有一个独立的Endpoint（IP+Port）访问点，但Kubernetes 能够让我们通过Service（虚拟Cluster IP+Service Port）连接到指定的Service上（NAT）? ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:4:2","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"。。。 ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:4:3","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Kubernetes"],"content":"相关操作命令 create -f name.yaml，将创建的yaml发布到集群中 位置 get rc 查看创建的RC文件 get pods 查看pod的情况 docker ps查看正在运行的容器 get service 查看服务 get node 查看集群有多少个Node kubectl describe node 查看某个Node的详细信息 删除节点/服务 kubectl delete node/service name kubectl describe node node1 查看详细信息 # 查看现在证书的过期时间 kubeadm alpha certs check-expiration # 更新证书 kubeadm alpha certs renew all # 修改配置 cd ~/.kube $ mv config conf.archive.2021 # Copy the new configuration file created using kubeadm $ cp /etc/kubernetes/admin.conf config # apply permissions to your current admin user and group $ sudo chown $(id -u):$(id -g) config ","date":"2023-05-02","objectID":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/:5:0","tags":["Kubernetes","云原生"],"title":"Kubernetes介绍（一）","uri":"/posts/kubernetes/kubernetes%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"本文主要是记录Dockerfile的一些基本命令，便于以后构建镜像查询 dockerfile FROM ubuntu:14.04 MAINTAINER YS.Zou \u003c\u003e ADD run /root/run ADD sources.list /etc/apt/sources.list ADD id_rsa.pub /tmp/pubkey ADD requirements /root/requirements RUN mkdir -p /root/.ssh \u0026\u0026 \\ cat /tmp/pubkey \u003e\u003e /root/.ssh/authorized_keys \u0026\u0026 \\ rm -rf /tmp/pubkey CMD [\"bash\", \"/root/run\"] FROM：基础镜像，当前新的镜像是基于哪个已经存在的镜像的 MAINTAINER：镜像作者及其邮箱 RUN：镜像构建时需要执行的命令 EXPOSE：暴露镜像的端口号 WORKDIR：指定在创建容器后，终端默认登录进来的工作目录，一个落脚点 ENV：用来在构建镜像过程中设置环境变量 ADD：将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包 COPY：跟ADD类似，拷贝文件和目录到镜像中 VOLUME：容器数据卷，用于数据保存和持久化工作 CMD：指定一个容器启动时要执行的命令，dockefile可以有多个cmd指令，但只有最后一个生效，cmd会被docker run之后的参数替换 ENTRYPOINT：指定一个容器启动时要执行的命令，和CMD的目的一样，都是在指定容器启动程序及参数 --entrpoint ONBUILD：当构建一个被继承的dockefile时运行命令，父镜像在被子继承后父镜像的onbuild被触发 ","date":"2023-05-02","objectID":"/posts/docker/dockerfile%E4%BB%8B%E7%BB%8D/:0:0","tags":["Docker"],"title":"Dockerfile介绍","uri":"/posts/docker/dockerfile%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"本文主要简单介绍了docker的数据持久化的方式，数据源和挂载主机目录 ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:0:0","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"数据管理方式 前面提到了启动容器实际上是静态层上面加了一层可读写层，但是如果我们对这个层进行读写，数据并不能固化，也保存不下来。所以为了保存数据，有下面两种方式来管理数据的保存。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:1:0","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"数据卷 数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷 可以在容器之间共享和重用 对 数据卷 的修改会立马生效 对 数据卷 的更新，不会影响镜像 数据卷 默认会一直存在，即使容器被删除 ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:2:0","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"创建一个数据卷 $ docker volume create my-vol 查看所有的 数据卷 $ docker volume ls DRIVER VOLUME NAME local my-vol 在主机里使用以下命令可以查看指定 数据卷 的信息 $ docker volume inspect my-vol [ { \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\", \"Name\": \"my-vol\", \"Options\": {}, \"Scope\": \"local\" } ] ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:2:1","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"启动一个卷挂载的容器 在用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。 下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /usr/share/nginx/html 目录。 $ docker run -d -P \\ --name web \\ # -v my-vol:/usr/share/nginx/html \\ --mount source=my-vol,target=/usr/share/nginx/html \\ nginx:alpine ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:2:2","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"查看数据卷的具体信息 在主机里使用以下命令可以查看 web 容器的信息 $ docker inspect web 数据卷 信息在 “Mounts” Key 下面 \"Mounts\": [ { \"Type\": \"volume\", \"Name\": \"my-vol\", \"Source\": \"/var/lib/docker/volumes/my-vol/_data\", \"Destination\": \"/usr/share/nginx/html\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" } ], ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:2:3","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"删除数据卷 $ docker volume rm my-vol 数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。 无主的数据卷可能会占据很多空间，要清理请使用以下命令 $ docker volume prune ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:2:4","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"挂载主机目录 ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:3:0","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"挂载一个主机目录作为数据卷 使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。 $ docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \\ nginx:alpine 上面的命令加载主机的 /src/webapp 目录到容器的 /usr/share/nginx/html目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。 Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读。 $ docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html:ro \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\ nginx:alpine 加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /usr/share/nginx/html 目录新建文件，会显示如下错误 /usr/share/nginx/html # touch new.txt touch: new.txt: Read-only file system ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:3:1","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"查看数据卷的具体信息 在主机里使用以下命令可以查看 web 容器的信息 $ docker inspect web 挂载主机目录 的配置信息在 “Mounts” Key 下面 \"Mounts\": [ { \"Type\": \"bind\", \"Source\": \"/src/webapp\", \"Destination\": \"/usr/share/nginx/html\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"rprivate\" } ], ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:3:2","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"挂载一个主机文件到容器中 --mount 标记也可以从主机挂载单个文件到容器中 $ docker run --rm -it \\ # -v $HOME/.bash_history:/root/.bash_history \\ --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \\ ubuntu:18.04 \\ bash root@2affd44b4667:/# history 1 ls 2 diskutil list 这样就可以记录在容器输入过的命令了。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/:3:3","tags":["Docker","云原生"],"title":"Docker数据卷","uri":"/posts/docker/docker%E6%95%B0%E6%8D%AE%E5%8D%B7/"},{"categories":["Docker"],"content":"本文主要介绍了docker相关的网络，网络模式，如何对外暴露服务 ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:0:0","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"网络 ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:1:0","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"外部访问容器 容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。 当使用 -P 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。 使用 docker container ls 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。 $ docker run -d -P nginx:alpine $ docker container ls -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fae320d08268 nginx:alpine \"/docker-entrypoint.…\" 24 seconds ago Up 20 seconds 0.0.0.0:32768-\u003e80/tcp bold_mcnulty 同样的，可以通过 docker logs 命令来查看访问记录。 $ docker logs fa 172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] \"GET / HTTP/1.1\" 200 612 \"-\" \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0\" \"-\" -p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:2:0","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"映射所有的接口地址 使用 hostPort:containerPort 格式本地的 80 端口映射到容器的 80 端口，可以执行 $ docker run -d -p 80:80 nginx:alpine 此时默认会绑定本地所有接口上的所有地址。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:2:1","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"映射到指定地址的指定端口 可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1 $ docker run -d -p 127.0.0.1:80:80 nginx:alpine ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:2:2","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"映射到指定地址的任意端口 使用 ip::containerPort 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。 $ docker run -d -p 127.0.0.1::80 nginx:alpine 还可以使用 udp 标记来指定 udp 端口 $ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:2:3","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"查看映射端口配置 使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址 $ docker port fa 80 0.0.0.0:32768 注意： 容器有自己的内部网络和 ip 地址（使用 docker inspect 查看，Docker 还可以有一个可变的网络配置。） -p 标记可以多次使用来绑定多个端口 例如 $ docker run -d \\ -p 80:80 \\ -p 443:443 \\ nginx:alpine ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:2:4","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"容器互联 随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 --link 参数。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:3:0","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"新建网络 下面先创建一个新的 Docker 网络。 $ docker network create -d bridge my-netd -d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 [Swarm mode] ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:3:1","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"连接容器 运行一个容器并连接到新建的 my-net 网络 $ docker run -it --rm --name busybox1 --network my-net busybox sh 打开新的终端，再运行一个容器并加入到 my-net 网络 $ docker run -it --rm --name busybox2 --network my-net busybox sh 再打开一个新的终端查看容器信息 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b47060aca56b busybox \"sh\" 11 minutes ago Up 11 minutes busybox2 8720575823ec busybox \"sh\" 16 minutes ago Up 16 minutes busybox1 下面通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。 在 busybox1 容器输入以下命令 / # ping busybox2 PING busybox2 (172.19.0.3): 56 data bytes 64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms 64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms 用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。 同理在 busybox2 容器执行 ping busybox1，也会成功连接到。 / # ping busybox1 PING busybox1 (172.19.0.2): 56 data bytes 64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms 64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms 这样，busybox1 容器和 busybox2 容器建立了互联关系，实现主机间通信必须要有一个dns服务器，而docker从1.10开始就在daemon中内嵌了一个dns服务器，同时需要注意的是，不指定容器名（采用随机分配的）无法通信，使用默认的docker网络无法通信。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:3:2","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"docker的网络模式 bridge 获取区别于docker0的网桥，独立于host host 使用主机网络 none，没有网络，常用于网络的 container 和某个容器共享网络 ","date":"2023-04-30","objectID":"/posts/docker/docker%E7%BD%91%E7%BB%9C/:4:0","tags":["Docker","云原生"],"title":"Docker网络","uri":"/posts/docker/docker%E7%BD%91%E7%BB%9C/"},{"categories":["Docker"],"content":"本文主要简单介绍了docker的一些基本概念和基本操作，以及实现方法 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:0:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"什么是docker Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术 。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC ，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontaine，从 1.11 版本开始，则进一步演进为使用 runC和 containerd，runc是一个命令行进程，通过OCI规范创建容器和运行容器。containerd是一个守护进程，它负责来管理容器的生命周期，在一个节点上执行容器和管理镜像的的最小功能集 cgroups，其名称源自控制组群（英语：control groups）的简写，是Linux内核的一个功能，用来限制、控制与分离一个进程组的资源（如CPU、内存、磁盘输入输出等） namespace命名空间是Linux 内核的一个特性，它对内核资源进行分区，使得一组进程看到一组资源，而另一组进程看到一组不同的资源。该功能的工作原理是为一组资源和进程使用相同的命名空间，但这些命名空间引用不同的资源。（8种，mnt，pid，net，ipc，uts，user，cgroup，time） ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:1:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"命名空间(namespace) ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:2:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"pid 命名空间 不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 容器进程在 Docker 中的父进程为 Docker 进程，每个 容器 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:2:1","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"net 命名空间 有了 pid 命名空间，每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备，IP 地址，路由表，/proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:2:2","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"ipc 命名空间 容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC)， 包括信号量、消息队列和共享内存等。但是和 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:2:3","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"mnt 命名空间 类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:2:4","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"uts 命名空间 UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:2:5","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"user 命名空间 每个容器可以有不同的用户和组 id， 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。 OverlayFS 是一个现代联合文件系统，类似于 AUFS，但速度更快，实现更简单。Docker 为 OverlayFS 提供了两个存储驱动程序：原始的overlay和更新更稳定的overlay2。联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。 联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。 Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。 runc 是一个 CLI 工具，用于根据 OCI 规范在 Linux 上生成和运行容器 containerd 就会负责集群节点上容器的生命周期管理，并向上为 Docker Daemon 提供 gRPC 接口。他可以管理其主机系统的完整容器生命周期：镜像传输和存储、容器执行和监督、低级存储和网络附件等。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:2:6","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"cgroup 资源限制 TODO: ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:3:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"为什么要使用 Docker ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:4:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"更高效的利用系统资源 由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:4:1","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"更快速的启动时间 传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:4:2","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"一致的运行环境 开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:4:3","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"持续交付和部署 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) (opens new window)系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) (opens new window)系统进行自动部署 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:4:4","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"对比传统虚拟机的优势 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:4:5","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"Docker整体结构 先了解一下docker三个比较重要的概念： ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:5:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"镜像 操作系统分为 内核 和 用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。由一组文件系统组成，或者说，由多层文件系统联合组成。 镜像本身都是静态的，通过union FS（联合文件系统技术）组成，是一组文件系统的集合。由多层文件系统联合 将镜像打包的时候，前一层是后一层的基础，每次把前一层文件删除的时候并不是真的删除，而是把这一层置为被删除状态。会一直跟随镜像 在仓库中看到的是镜像压缩后的大小，关注的是下载的流量大小。在本地看到的时候镜像本身每一层大小的总和，关注的是占用磁盘的大小 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:5:1","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"容器 镜像（Image）和容器（Container）的关系，就像是面向对象中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间，就是在一个封闭独立的环境中。 每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失 镜像是静态的文件系统，容器是镜像运行时的实体。本质上是进程，或者一组进程的集合，但是有自己的命名空间（网络，文件，pid，用户等），运行在一个隔离的环境中。 容器运行时，在镜像的上面创建一个属于当前容器的存储层，这个存储层可读写。当容器重启的时候，这个可可读写层就会随之消亡。所以一般不可以在可读写层写入数据，一般使用挂载卷或者共享主机目录来实现数据持久化。 containerd-shim存在的必要性 docker是怎么删掉的 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:5:2","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"仓库 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务 容器的启动流程如下： 通过命令行和docker的守护进程交互，来对容器操作 当docker-daemon收到消息之后来请求containerd来帮我们创建容器 Containerd也不直接操作容器，先创建一个containerd-shim的进程。这个进程就是负责收集容器状态，容器的输入输出，异常（stdin），上报给containerd。 Runc是containerd-shim启动的一个进程，这个进程负责创建一个符合oci规范的容器，创建完就会退出，接下来起来的这个容器就会被containerd-shim接管。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:5:3","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"Docker的常用命令 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:6:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"对镜像的操作 Docker rmi 删除镜像 Docker load -i 加载镜像 Docker tag 给镜像打标记 docker build -tag –rm ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:6:1","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"对仓库的操作 docker login docker push docker pull ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:6:2","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"对容器的操作 docker exec/ attach -itd -v –name -p –network -t 给容器分配一个伪终端绑定到容器上，-i 容器的标准输入打开 -d 守护态运行，运行在后台 docker logs docker stats docker inspect docker rm/ stop/ start/ restart / docker events ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:6:3","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"通过docker run 启动一个容器，发生了什么 检查本地是否存在指定的镜像，不存在就从仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:7:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"定制镜像的原则 每一层都有特定的意义，不要分开构建基础层，Dockerfile中的每一个命令都是一层。如果每一层都分开执行，会变得很臃肿 联合文件系统的最大层数限制是127 查看镜像的分层 docker history ls ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:8:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"本文主要介绍git的基本原理和一些简单的基础操作 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:0:0","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"什么是Git Git是一种版本控制系统，方便开发者管理版本内容，同时方便多用户协同工作。不同于svn，它是一种分布式的内容管理系统。同时Git和svn的区别还体现在Git的分支，而svn的分支就是一个单独的目录，也就是说，把主线上的内容拷贝一份就是一个新的分支，单纯对目录的拷贝。对于svn来说，他每一个单独的分支都有，每一次提交之后都会有不同基于全局的版本号，而Git并没有 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:1:0","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"Git简单介绍 一般来说，我们使用Git，通常情况下会把本地仓库和远程仓库的内容进行同步 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:2:0","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"本地仓库 一般来说，Git在本地主要由“三棵树”来维护，第一棵树就是工作区，第二棵树暂存区，第三棵树是HEAD “第一棵树”——工作区 这里存放的是实际的工作内容 “第二棵树”——暂存区（Index） “第三棵树”——HEAD 他指向你的最后一次提交结果 简要使用情况说明 首先，可以通过git init或者git clone来创建或者克隆一个仓库到本地，在这个目录下面有一个.git的隐藏文件，在这个文件会保存暂存区的提交。 然后在本地的仓库目录生成文件或者创建新的目录。此时文件仅仅存在于你的工作区中。 通过git add \u003cfile or directory\u003e把在工作区的文件添加到暂存区中，这事也就意味着，这个目录或者文件开始受到版本管理。 此时实体文件既保存在工作区也保存在暂存区，但是还没有提交到HEAD。我们可以通过git commit \u003cfile or directory\u003e来把暂存区的文件提交到HEAD中。完成提交 最后采用git push orign HEAD 就是把HEAD中的文件推送到远端仓库 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:2:1","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"远端仓库 TODO: ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:2:2","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"基本操作 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:0","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"证书相关 ssh-keygen -t rsa -C “email@163.com” 需要执行 ssh -T git@github.com 来认证 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:1","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git config 配置的相关问题 git config –global user.name “name” git config –global user.email “email” git config –list 查看所有的config git config –global init.defaultBranch dev git 修改生成的默认分支名 git config –global core.eitor vim 配置git的默认编辑器是vim ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:2","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 分支相关的问题 git branch 查看分支 git checkout -b “name” 创建一个新分支并切换到新分支上 git checkout “name” 切换分支 git brach -d “name” 删除分支 git merge 源分支 合并分支 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:3","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 冲突的相关问题（合并代码） git stash git push orign master git stash pop ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:4","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 工作区 git add filename 添加工作区的目录到暂存区 git checkout filename 撤销工作区的修改（慎用）,必须要在版本管理之下,如果是新增的文件只能使用rm git rm 删除本地文件 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:5","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 暂存区 git rm –cached git 删除添加到暂存区的文件 git reset filename 将暂存区的文件撤销 git restore –staged 删除通过git add添加到暂存区的文件，但是保留本地的 git rm –cached 工作区被删除，暂存区还保留，恢复到本地 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:6","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 本地仓库 git ci -m “message” 把暂存区的文件提交到本地仓库 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:7","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 远端仓库 git init 初始化一个远程仓库 git remote add origin url 给本地仓库添加远程连接 git remote set-url origin git更换远程连接地址 git pull origin 更新该分支代码 git push origin 把本地的改动推送到远端仓库 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:8","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 撤销conmmit git reset –soft HEAD^ 撤销commit，不改动工作区的代码，保留add git reset –hard HEAD^ 删除工作空间的改动代码，撤销commit 撤销add git commit -amend 修改本次的commit记录 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:9","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"Github更新记录 ","date":"2023-04-29","objectID":"/about/:0:1","tags":null,"title":"关于我","uri":"/about/"},{"categories":null,"content":"阅读记录 书名 进度 笔记 《docker从入门到实践》 80% 进行中 ","date":"2023-04-29","objectID":"/about/:1:0","tags":null,"title":"关于我","uri":"/about/"},{"categories":["Golang"],"content":"摘要 正文 ","date":"2023-04-28","objectID":"/posts/go/go%E4%B8%80/:0:0","tags":["Gloang"],"title":"go(一)","uri":"/posts/go/go%E4%B8%80/"},{"categories":["软件安装"],"content":"本文主要记录了tmux的安装和使用方式 Tmux 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称\"窗口\"），在里面输入命令。用户与计算机的这种临时的交互，称为一次\"会话\"（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 为了解决这个问题，会话与窗口可以\"解绑\"：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话\"绑定\"其他窗口。 ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:0:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"Tmux的作用 Tmux 就是会话与窗口的\"解绑\"工具，将它们彻底分离。 - 它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 - 它可以让新窗口\"接入\"已经存在的会话。 - 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 - 它还支持窗口任意的垂直和水平拆分。 Tmux的使用 ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"前缀键 Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。 我的Tmux前缀键是Ctrl+x，即先按下Ctrl+x ，快捷键才会生效 会话管理 ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:2:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"新建会话 第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。 使用编号区分会话，不太直观，更好的方法是为会话起名 tmux new -s \u003csessione name\u003e 快捷键 ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:3:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"会话快捷键 切换回命令行 d（前缀键+d 或者 tmux detch） 接入某个会话 （tmux attach -t 会话ID/会话名称） 查看当前所有的会话 （tmux ls /前缀 + s) 从当前会话切换到另一个会话（tmux switch -t 会话ID/会话名称） 重命名会话 (tmux rename-session -t 0 会话名称 $重命名当前会话) ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"窗口快捷键 查看所有的窗口 （前缀+w） 退出窗口 （前缀+c） 重命名窗口 （前缀+ ,） 创建新窗口 （前缀+c） 切换下一个窗口 p，切换上一个窗口 n， 切换指定窗口 编号 ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:5:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"窗格快捷键 退出窗格（前缀 + c） 左右两个窗格 （前缀+ %） 上下两个窗格 （前缀+“） 光标切换 （前缀+/o） 窗格交换位置 （前缀+{}） 窗格移动 （前缀+Ctrl+o） 窗格变成窗口（前缀+ ！） 当前窗格全屏显示（前缀+z） ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:6:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"修改前缀键 在当前用户的根目录下面创建一个.tmux.conf 文件， 文件中添加set -g prefix C-x ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:7:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]