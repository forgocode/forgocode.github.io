[{"categories":["Docker"],"content":"本文主要简单介绍了docker的一些基本概念和基本操作，以及实现方法 什么是docker Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术 。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC ，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontaine，从 1.11 版本开始，则进一步演进为使用 runC和 containerd，runc是一个命令行进程，通过OCI规范创建容器和运行容器。containerd是一个守护进程，它负责来管理容器的生命周期，在一个节点上执行容器和管理镜像的的最小功能集 cgroups，其名称源自控制组群（英语：control groups）的简写，是Linux内核的一个功能，用来限制、控制与分离一个进程组的资源（如CPU、内存、磁盘输入输出等） namespace命名空间是Linux 内核的一个特性，它对内核资源进行分区，使得一组进程看到一组资源，而另一组进程看到一组不同的资源。该功能的工作原理是为一组资源和进程使用相同的命名空间，但这些命名空间引用不同的资源。（8种，mnt，pid，net，ipc，uts，user，cgroup，time） ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:0:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"命名空间(namespace) ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:1:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"pid 命名空间 不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 容器进程在 Docker 中的父进程为 Docker 进程，每个 容器 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:1:1","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"net 命名空间 有了 pid 命名空间，每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备，IP 地址，路由表，/proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:1:2","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"ipc 命名空间 容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC)， 包括信号量、消息队列和共享内存等。但是和 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:1:3","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"mnt 命名空间 类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:1:4","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"uts 命名空间 UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:1:5","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"user 命名空间 每个容器可以有不同的用户和组 id， 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。 OverlayFS 是一个现代联合文件系统，类似于 AUFS，但速度更快，实现更简单。Docker 为 OverlayFS 提供了两个存储驱动程序：原始的overlay和更新更稳定的overlay2。联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。 联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。 另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。 Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。 runc 是一个 CLI 工具，用于根据 OCI 规范在 Linux 上生成和运行容器 containerd 就会负责集群节点上容器的生命周期管理，并向上为 Docker Daemon 提供 gRPC 接口。他可以管理其主机系统的完整容器生命周期：镜像传输和存储、容器执行和监督、低级存储和网络附件等。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:1:6","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"cgroup 资源限制 TODO: ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:2:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"为什么要使用 Docker ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:3:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"更高效的利用系统资源 由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:3:1","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"更快速的启动时间 传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:3:2","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"一致的运行环境 开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:3:3","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"持续交付和部署 使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) (opens new window)系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) (opens new window)系统进行自动部署 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:3:4","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"对比传统虚拟机的优势 特性 容器 虚拟机 启动 秒级 分钟级 硬盘使用 一般为 MB 一般为 GB 性能 接近原生 弱于 系统支持量 单机支持上千个容器 一般几十个 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:3:5","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"Docker整体结构 先了解一下docker三个比较重要的概念： ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:4:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"镜像 操作系统分为 内核 和 用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。由一组文件系统组成，或者说，由多层文件系统联合组成。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:5:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"容器 镜像（Image）和容器（Container）的关系，就像是面向对象中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间，就是在一个封闭独立的环境中。 每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为 容器存储层。 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。 containerd-shim存在的必要性 docker是怎么删掉的 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:6:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"仓库 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务 容器的启动流程如下： 通过命令行和docker的守护进程交互，来对容器操作 当docker-daemon收到消息之后来请求containerd来帮我们创建容器 Containerd也不直接操作容器，先创建一个containerd-shim的进程。这个进程就是负责收集容器状态，容器的输入输出，异常（stdin），上报给containerd。 Runc是containerd-shim启动的一个进程，这个进程负责创建一个符合oci规范的容器，创建完就会退出，接下来起来的这个容器就会被containerd-shim接管。 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:7:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"Docker的常用命令 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:8:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"对镜像的操作 Docker rmi 删除镜像 Docker load -i 加载镜像 Docker tag 给镜像打标记 docker build -tag –rm ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:8:1","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"对仓库的操作 docker login docker push docker pull ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:8:2","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"对容器的操作 docker exec/ attach -itd -v –name -p –network -t 给容器分配一个伪终端绑定到容器上，-i 容器的标准输入打开 -d 守护态运行，运行在后台 docker logs docker stats docker inspect docker rm/ stop/ start/ restart / docker events ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:8:3","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Docker"],"content":"通过docker run 启动一个容器，发生了什么 检查本地是否存在指定的镜像，不存在就从仓库下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 ","date":"2023-04-30","objectID":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/:9:0","tags":["Docker","云原生"],"title":"Docker介绍","uri":"/posts/docker/docker%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"本文主要介绍git的基本原理和一些简单的基础操作 什么是Git Git是一种版本控制系统，方便开发者管理版本内容，同时方便多用户协同工作。不同于svn，它是一种分布式的内容管理系统。同时Git和svn的区别还体现在Git的分支，而svn的分支就是一个单独的目录，也就是说，把主线上的内容拷贝一份就是一个新的分支，单纯对目录的拷贝。对于svn来说，他每一个单独的分支都有，每一次提交之后都会有不同基于全局的版本号，而Git并没有 Git简单介绍 一般来说，我们使用Git，通常情况下会把本地仓库和远程仓库的内容进行同步 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:0:0","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"本地仓库 一般来说，Git在本地主要由“三棵树”来维护，第一棵树就是工作区，第二棵树暂存区，第三棵树是HEAD ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:1:0","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"“第一棵树”——工作区 这里存放的是实际的工作内容 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:1:1","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"“第二棵树”——暂存区（Index） ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:1:2","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"“第三棵树”——HEAD 他指向你的最后一次提交结果 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:1:3","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"合并代码（解决冲突） git stash git push orign master git stash pop ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:1:4","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"简要使用情况说明 首先，可以通过git init或者git clone来创建或者克隆一个仓库到本地，在这个目录下面有一个.git的隐藏文件，在这个文件会保存暂存区的提交。 然后在本地的仓库目录生成文件或者创建新的目录。此时文件仅仅存在于你的工作区中。 通过git add \u003cfile or directory\u003e把在工作区的文件添加到暂存区中，这事也就意味着，这个目录或者文件开始受到版本管理。 此时实体文件既保存在工作区也保存在暂存区，但是还没有提交到HEAD。我们可以通过git commit \u003cfile or directory\u003e来把暂存区的文件提交到HEAD中。完成提交 最后采用git push orign HEAD 就是把HEAD中的文件推送到远端仓库 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:1:5","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"远端仓库 TODO: ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:2:0","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"基本操作 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:0","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"证书相关 ssh-keygen -t rsa -C “email@163.com” 需要执行 ssh -T git@github.com 来认证 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:1","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git config 配置的相关问题 git config –global user.name “name” git config –global user.email “email” git config –list 查看所有的config git config –global init.defaultBranch dev git 修改生成的默认分支名 git config –global core.eitor vim 配置git的默认编辑器是vim ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:2","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 分支相关的问题 git branch 查看分支 git checkout -b “name” 创建一个新分支并切换到新分支上 git checkout “name” 切换分支 git brach -d “name” 删除分支 git merge 源分支 合并分支 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:3","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 冲突的相关问题 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:4","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 工作区 git add filename 添加工作区的目录到暂存区 git checkout filename 撤销工作区的修改（慎用）,必须要在版本管理之下,如果是新增的文件只能使用rm git rm 删除本地文件 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:5","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 暂存区 git rm –cached git 删除添加到暂存区的文件 git reset filename 将暂存区的文件撤销 git restore –staged 删除通过git add添加到暂存区的文件，但是保留本地的 git rm –cached 工作区被删除，暂存区还保留，恢复到本地 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:6","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 本地仓库 git ci -m “message” 把暂存区的文件提交到本地仓库 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:7","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 远端仓库 git init 初始化一个远程仓库 git remote add origin url 给本地仓库添加远程连接 git remote set-url origin git更换远程连接地址 git pull origin 更新该分支代码 git push origin 把本地的改动推送到远端仓库 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:8","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Git"],"content":"git 撤销conmmit git reset –soft HEAD^ 撤销commit，不改动工作区的代码，保留add git reset –hard HEAD^ 删除工作空间的改动代码，撤销commit 撤销add git commit -amend 修改本次的commit记录 ","date":"2023-04-30","objectID":"/posts/git/git%E4%BB%8B%E7%BB%8D/:3:9","tags":["Git"],"title":"Git介绍","uri":"/posts/git/git%E4%BB%8B%E7%BB%8D/"},{"categories":["Golang"],"content":"摘要 正文 ","date":"2023-04-28","objectID":"/posts/go/go%E4%B8%80/:0:0","tags":["Gloang"],"title":"go(一)","uri":"/posts/go/go%E4%B8%80/"},{"categories":["软件安装"],"content":"本文主要记录了tmux的安装和使用方式 Tmux 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称\"窗口\"），在里面输入命令。用户与计算机的这种临时的交互，称为一次\"会话\"（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 为了解决这个问题，会话与窗口可以\"解绑\"：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话\"绑定\"其他窗口。 ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:0:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"Tmux的作用 Tmux 就是会话与窗口的\"解绑\"工具，将它们彻底分离。 - 它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 - 它可以让新窗口\"接入\"已经存在的会话。 - 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 - 它还支持窗口任意的垂直和水平拆分。 Tmux的使用 ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"前缀键 Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。 我的Tmux前缀键是Ctrl+x，即先按下Ctrl+x ，快捷键才会生效 会话管理 ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:2:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"新建会话 第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。 使用编号区分会话，不太直观，更好的方法是为会话起名 tmux new -s \u003csessione name\u003e 快捷键 ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:3:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"会话快捷键 切换回命令行 d（前缀键+d 或者 tmux detch） 接入某个会话 （tmux attach -t 会话ID/会话名称） 查看当前所有的会话 （tmux ls /前缀 + s) 从当前会话切换到另一个会话（tmux switch -t 会话ID/会话名称） 重命名会话 (tmux rename-session -t 0 会话名称 $重命名当前会话) ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:4:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"窗口快捷键 查看所有的窗口 （前缀+w） 退出窗口 （前缀+c） 重命名窗口 （前缀+ ,） 创建新窗口 （前缀+c） 切换下一个窗口 p，切换上一个窗口 n， 切换指定窗口 编号 ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:5:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"窗格快捷键 退出窗格（前缀 + c） 左右两个窗格 （前缀+ %） 上下两个窗格 （前缀+“） 光标切换 （前缀+/o） 窗格交换位置 （前缀+{}） 窗格移动 （前缀+Ctrl+o） 窗格变成窗口（前缀+ ！） 当前窗格全屏显示（前缀+z） ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:6:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":["软件安装"],"content":"修改前缀键 在当前用户的根目录下面创建一个.tmux.conf 文件， 文件中添加set -g prefix C-x ","date":"2023-04-28","objectID":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:7:0","tags":["安装"],"title":"Tmux安装教程","uri":"/posts/tmux%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"}]